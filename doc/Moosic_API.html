<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Moosic_API - How to write your own Moosic client.</title>
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#section_0__instructions_for_impatient_developers">Section 0: Instructions for Impatient Developers</a></li>
	<li><a href="#section_1__the_moosic_server_s_data_model">Section 1: The Moosic Server's Data Model</a></li>
	<li><a href="#section_2__the_lowlevel_details_of_clientserver_communication">Section 2: The Low-Level Details of Client-Server Communication</a></li>
	<li><a href="#section_3__valid_moosic_server_methods">Section 3: Valid Moosic Server Methods</a></li>
	<li><a href="#section_4__writing_a_moosic_client_in_python">Section 4: Writing a Moosic Client in Python</a></li>
	<li><a href="#section_5__writing_a_moosic_client_in_another_language">Section 5: Writing a Moosic Client in Another Language</a></li>
	<li><a href="#section_6__api_version_history__changelog_">Section 6: API Version History (ChangeLog)</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Moosic_API - How to write your own Moosic client.</p>
<p>
</p>
<hr />
<h1><a name="introduction">Introduction</a></h1>
<p>``moosicd'' is a program that implements the server portion of the Moosic jukebox
system.  This server provides services for manipulating a queue of songs to be
played, as well as for controlling the playing of these songs.  A Moosic client
sends requests to the server, and receives data in response to these requests.
The ``moosic'' command line utility is the canonical Moosic client, and provides
a way to control a Moosic server from an interactive command shell or from a
shell script.  However, you might not be satisfied by the interface that is
provided by the ``moosic'' command, so I have written this document to describe
how to communicate with a Moosic server in your own programs.</p>
<p>[This document was written by Daniel Pearson &lt;<a href="mailto:daniel@nanoo.org">daniel@nanoo.org</a>&gt;, and has
been placed into the public domain.]</p>
<p>
</p>
<hr />
<h1><a name="section_0__instructions_for_impatient_developers">Section 0: Instructions for Impatient Developers</a></h1>
<ol>
<li></li>
Plan to write your program with Python and xmlrpclib. xmlrpclib is included with
Python 2.2 or later, but if you need to use an earlier version of Python,
xmlrpclib can be downloaded from <a href="http://www.pythonware.com/products/xmlrpc/">http://www.pythonware.com/products/xmlrpc/</a>.
<p></p>
<li></li>
If you can't or don't want to write your program with Python and xmlrpclib, you
won't benefit from this section and will have to read section 2 of this
document.
<p></p>
<li></li>
Create a proxy which communicates with moosicd:
<pre>
   &gt;&gt;&gt; import moosic.client.factory
   &gt;&gt;&gt; proxy = moosic.client.factory.LocalMoosicProxy()</pre>
<p></p>
<li></li>
Read section 3 for the documentation of all the methods supported by the proxy
object.
<p></p>
<li></li>
Use the proxy to get information from the server and to send commands to it.
For example:
<pre>
   &gt;&gt;&gt; proxy.list()
   []
   &gt;&gt;&gt; proxy.is_queue_running()
   True
   &gt;&gt;&gt; proxy.haltqueue()
   True
   &gt;&gt;&gt; proxy.is_queue_running()
   False
   &gt;&gt;&gt; proxy.append([xmlrpc.Binary(i) for i in 
   ...       ['/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3',
   ...        '/home/daniel/music/Fiona_Apple/When_The_Pawn/04-Love_Ridden.ogg',
   ...        &quot;/home/daniel/music/Zelda/Great_Fairy's_Fountain.mid&quot;]])
   True
   &gt;&gt;&gt; proxy.list()
   [&lt;xmlrpclib.Binary instance at 0x843cf3c&gt;,
    &lt;xmlrpclib.Binary instance at 0x8440e94&gt;,
    &lt;xmlrpclib.Binary instance at 0x8440ebc&gt;]
   &gt;&gt;&gt; [i.data for i in proxy.list()]
   ['/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3',
    '/home/daniel/music/Fiona_Apple/When_The_Pawn/04-Love_Ridden.ogg',
    &quot;/home/daniel/music/Zelda/Great_Fairy's_Fountain.mid&quot;]
   &gt;&gt;&gt; proxy.sort()
   True
   &gt;&gt;&gt; [i.data for i in proxy.list()]
   ['/home/daniel/music/Fiona_Apple/When_The_Pawn/04-Love_Ridden.ogg',
    '/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3',
    &quot;/home/daniel/music/Zelda/Great_Fairy's_Fountain.mid&quot;]</pre>
<p></p>
<li></li>
If you wish to communicate with a moosicd that is listening for requests on
an IP socket instead of a Unix domain socket, you should use InetMoosicProxy
instead of LocalMoosicProxy.  Here's an example:
<pre>
   &gt;&gt;&gt; import moosic.client.factory
   &gt;&gt;&gt; proxy = moosic.client.factory.InetMoosicProxy('example.com', 8080)</pre>
<p></p></ol>
<p>
</p>
<hr />
<h1><a name="section_1__the_moosic_server_s_data_model">Section 1: The Moosic Server's Data Model</a></h1>
<p>This section describes, in precise terms, the data objects that can be accessed
and manipulated by sending requests to the Moosic server.</p>
<dl>
<dt><strong><a name="item_song_queue">song queue</a></strong><br />
</dt>
<dd>
This is the foremost data object maintained by the Moosic server. It is an
ordered sequence of strings that represents the queue of songs that are waiting
to be played.  Each item in this list identifies a song that will be played by
the Moosic server.  Usually, these items are the names of files on disk that
contain each song, but this does not have to be the case.  For instance, an HTTP
URL might be used to name a song if a program that can play songs from the Web
is appropriately registered with the Moosic server (see ``player configuration''
later in this section).
</dd>
<p></p>
<dt><strong><a name="item_current_song">current song</a></strong><br />
</dt>
<dd>
This is a string that identifies the song that is currently being played by the
Moosic server.  If nothing is currently playing, then this will be the empty
string.
</dd>
<p></p>
<dt><strong><a name="item_queue_running_flag">queue running flag</a></strong><br />
</dt>
<dd>
This is a boolean value that indicates whether the Moosic server will start
playing a new song as soon as the current song has finished and the song queue
is not empty.
</dd>
<p></p>
<dt><strong><a name="item_pause_flag">pause flag</a></strong><br />
</dt>
<dd>
This is a boolean value that indicates whether the current song is paused or
not.
</dd>
<p></p>
<dt><strong><a name="item_loop_mode_flag">loop mode flag</a></strong><br />
</dt>
<dd>
This is a boolean value that sets ``loop mode''.  When loop mode is on, songs are
returned to the end of the song queue when they finish playing instead of being
discarded.
</dd>
<p></p>
<dt><strong><a name="item_history">history</a></strong><br />
</dt>
<dd>
This is a list of songs that the Moosic server has finished playing.  Note that
songs named in this list may have finished playing early at the request of a
user (i.e. through use of the ``next'' command).  Each entry in this list is
actually a 3-tuple of (song, start time, finish time).
</dd>
<p></p>
<dt><strong><a name="item_maximum_history_size">maximum history size</a></strong><br />
</dt>
<dd>
This is the maximum number of songs that will be stored in the history list.
Old entries are removed from the history to make room for newer entries when
this limit is reached.
</dd>
<p></p>
<dt><strong><a name="item_player_configuration">player configuration</a></strong><br />
</dt>
<dd>
This is an ordered mapping that associates regular expressions (text patterns)
to programs.  For each regular expression, the associated program is expected to
be able to play any queue items that match that regular expression.  Each
program is a list in which the name of the executable file that contains the
program is the first element and the program's arguments are the rest of the
elements.
</dd>
<p></p>
<dt><strong><a name="item_last_queue_update">last queue update</a></strong><br />
</dt>
<dd>
This is the time at which the song queue was last modified.  It a floating-point
number that represents time as the number of seconds since the epoch.
</dd>
<p></p>
<dt><strong><a name="item_server_version">server version</a></strong><br />
</dt>
<dd>
This is a string that describes the version of the program that implements the
Moosic server.  It has no specific, well-defined semantics.
</dd>
<p></p>
<dt><strong><a name="item_api_version">API version</a></strong><br />
</dt>
<dd>
This is a pair of integers, one representing the ``major'' version, and the other
representing the ``minor'' version.  These numbers are meant to provide some
useful compatibility information to Moosic clients.  As this API changes, these
numbers will change in the following ways.  If the API has been changed in a
backward-compatible way (e.g. a new method was added or an existing method was
overloaded), then the minor version will increase and the major version will
remain unchanged.  However, if the API has been changed in such a way that
existing code that uses the API might break (e.g.  a method was removed or its
return value or parameter types were changed), then the major version will
increase and the minor version may be reset to any value (although it will
usually be reset zero).
</dd>
<p></p></dl>
<p>
</p>
<hr />
<h1><a name="section_2__the_lowlevel_details_of_clientserver_communication">Section 2: The Low-Level Details of Client-Server Communication</a></h1>
<p>The information in this section is generally only necessary to people who wish
to write a Moosic client in a programming language other than Python.  If you
are using Python to write a Moosic client, then you can use the classes
LocalMoosicProxy and InetMoosicProxy from the moosic_factory.py module, and
blissfully ignore most of these gory details.  However, Python programmers can
also benefit from reading this section, as it will deepen their understanding of
Moosic's inter-process communication model.</p>
<p>The first thing to know about writing your own Moosic client is that
communication between the client and server is done through a BSD-style socket.
Read the ``socket'' manual page (and related manual pages) on a Unix system if you
are unfamiliar with BSD sockets.  The socket used by Moosic belongs to the
Unix-domain protocol family (PF_UNIX or PF_LOCAL) and has a type of SOCK_STREAM.
This means that a Moosic client can only communicate with a Moosic server that
is running on the same computer as the client.  This limitation is a very
purposeful part of Moosic's design.  It has the advantage of vastly reducing the
consequences of any security flaws that Moosic might have.</p>
<p>If you really, really think that you need the client and the server to run on
separate hosts, then you can run moosicd with the -t option, which tells it to
listen on a TCP/IP socket instead of a Unix domain socket.  I recommend
firewalling such a port very carefully.</p>
<p>Regardless of which kind of socket is used by the server, XML-RPC is used as the
data protocol for requests and responses.  For an introduction to XML-RPC, see
the XML-RPC homepage <a href="http://www.xmlrpc.com/">http://www.xmlrpc.com/</a> and the XML-RPC HOWTO
<a href="http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto.html">http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto.html</a>.  Python users
should note that if the XML-RPC HOWTO tells you that you need to install a
third-party library to use XML-RPC, it is assuming that you are using a Python
version earlier than 2.2.  Since version 2.2, Python has included the xmlrpclib
module in its standard library.</p>
<p>In summary, all you need to do to talk to a Moosic server in your own program is
to send XML-RPC requests to the appropriate address.  By default, the
appropriate address for contacting moosicd is the file named ``socket'' in a
directory named ``.moosic'' in the home directory of the user that started moosicd
(i.e. ``~/.moosic/socket'').  If moosicd is started with the -c option, then the
directory that contains ``socket'' will be the argument provided to the -c option
instead of ~/.moosic.  If moosicd is started with the -t option, then clients
will have to address it by using a (host, port) pair instead of a filename.</p>
<p>
</p>
<hr />
<h1><a name="section_3__valid_moosic_server_methods">Section 3: Valid Moosic Server Methods</a></h1>
<p>moosicd's XML-RPC server implements the introspection API mentioned on
<a href="http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto-api-introspection.html">http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto-api-introspection.html</a>,
so the API presented by moosicd is essentially self-documenting.  Thus, the
information in this section has been automatically generated by querying a
running Moosic server.</p>
<p>The Moosic API contains the following methods:</p>
<dl>
<dt><strong><a name="item_api_version">array <strong>api_version</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns the version number for the API that the server implements.
    
       Arguments: None.
       Return value: The version number, which is a 2-element array of
           integers.  The first element is the major version, and the second
           element is the minor version.</pre>
</dd>
<dt><strong><a name="item_append">boolean <strong>append</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Adds items to the end of the queue.
    
       Argument: An array of (base64-encoded) strings, representing the items to be
           added.
         * When adding local filenames to the queue, only absolute pathnames should
           be used.  Using relative pathnames would be foolish because the server
           has no idea what the client's current working directory is.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_clear">boolean <strong>clear</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Removes all items from the queue.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_crop">boolean <strong>crop</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Remove all queued items that do not fall within the given range.
    
       Arguments: An array of integers that represents a range.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_crop_list">boolean <strong>crop_list</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Removes all items except for those referenced by a list of positions.
       
       Arguments: An array of integers that represents a list of the positions of
           the items to be kept. 
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_current">base64 <strong>current</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns the name of the currently playing song.
    
       Arguments: None.
       Return value: The name of the currently playing song.</pre>
</dd>
<dt><strong><a name="item_current_time">double <strong>current_time</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns the amount of time that the current song has been playing.
    
       Arguments: None.
       Return value: The number of seconds that the current song has been playing.</pre>
</dd>
<dt><strong><a name="item_cut">boolean <strong>cut</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Remove all queued items that fall within the given range.
    
       Arguments: An array of integers that represents a range.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_cut_list">boolean <strong>cut_list</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Removes the items referenced by a list of positions within the queue.
       
       Arguments: An array of integers that represents a list of the positions of
           the items to be removed. 
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_die">boolean <strong>die</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Tells the server to terminate itself.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_filter">boolean <strong>filter</strong> (base64)</a></strong><br />
</dt>
<dt><strong>boolean <strong>filter</strong> (base64, array)</strong><br />
</dt>
<dd>
<pre>
   Removes all items that don't match the given regular expression.
    
       Arguments: A regular expression that specifies which items to keep.
         * Optionally, an array of integers may be given as a second argument.
           This argument represents a range to which the filtering will be
           limited.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_get_history_limit">int <strong>get_history_limit</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Gets the limit on the size of the history list stored in memory.
    
       Arguments: None.
       Return value: The maximum number of history entries that the server will
           remember.</pre>
</dd>
<dt><strong><a name="item_getconfig">array <strong>getconfig</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns a list of the server's filetype-player associations.
       
       Arguments: None.
       Return value: An array of pairs. The first element of each pair is a
           (base64-encoded) string that represents a regular expression pattern,
           and the second element is a (base64-encoded) string that represents the
           system command that should be used to handle songs that match the
           corresponding pattern.</pre>
</dd>
<dt><strong><a name="item_halt_queue">boolean <strong>halt_queue</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Stops any new songs from being played. Use run_queue() to reverse this
       state.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_haltqueue">boolean <strong>haltqueue</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Stops any new songs from being played. Use run_queue() to reverse this
       state.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong>array <strong>history</strong> ()</strong><br />
</dt>
<dt><strong>array <strong>history</strong> (int)</strong><br />
</dt>
<dd>
<pre>
   Returns a list of the items that were recently played.
    
       Arguments: If a positive integer argument is given, then no more than that
           number of entries will be returned.  If a number is not specified, or if
           zero is given, then the entire history is returned.  The result is
           undefined if a negative integer argument is given (but does not raise an
           exception).
       Return value: An array of triples, each representing a song that was played
           along with the times that it started and finished playing.
         * The first member of the pair is a (base64-encoded) string which
           represents the song that was previously played.
         * The second member of the pair is a floating point number which
           represents the time that the song started playing in seconds since the
           epoch.
         * The third member of the pair is a floating point number which
           represents the time that the song finished playing in seconds since the
           epoch.</pre>
</dd>
<dt><strong><a name="item_indexed_list">struct <strong>indexed_list</strong> ()</a></strong><br />
</dt>
<dt><strong>struct <strong>indexed_list</strong> (array)</strong><br />
</dt>
<dd>
<pre>
   Lists the song queue's contents. If a range is specified, only the
       items that fall within that range are listed.
    
       This differs from list() only in its return value, and is useful when you
       want to know the starting position of your selected range within the song
       queue (which can be different than the starting index of the specified range
       if, for example, the starting index is a negative integer).
    
       Arguments: Either none, or an array of integers that represents a range.
         * If no range is given, the whole list is returned.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: A struct with two elements. This first is &quot;list&quot;, an array of
           (base64-encoded) strings, representing the selected range from the song
           queue's contents. The second is &quot;start&quot;, an integer index value that
           represents the position of the first item of the returned list in the
           song queue.</pre>
</dd>
<dt><strong><a name="item_insert">boolean <strong>insert</strong> (array, int)</a></strong><br />
</dt>
<dd>
<pre>
   Inserts items at a given position in the queue.
    
       Arguments: The first argument is an array of (base64-encoded) strings,
           representing the items to be added.
         * The second argument specifies the position in the queue where the items
           will be inserted.
         * When adding local filenames to the queue, only absolute pathnames should
           be used.  Using relative pathnames would be foolish because the server
           has no idea what the client's current working directory is.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_is_looping">boolean <strong>is_looping</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Tells you whether loop mode is on or not.
    
       If loop mode is on, songs are returned to the end of the song queue after
       they finish playing.  If loop mode is off, songs that have finished playing
       are not returned to the queue.
    
       Arguments: None.
       Return value: True if loop mode is set, False if it is not.</pre>
</dd>
<dt><strong><a name="item_is_paused">boolean <strong>is_paused</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Tells you whether the current song is paused or not.
    
       Arguments: None.
       Return value: True if the current song is paused, otherwise False.</pre>
</dd>
<dt><strong><a name="item_is_queue_running">boolean <strong>is_queue_running</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Tells you whether the queue consumption (advancement) is activated.
    
       Arguments: None.
       Return value: True if new songs are going to be played from the queue after
           the current song is finished, otherwise False.</pre>
</dd>
<dt><strong>double <strong>last_queue_update</strong> ()</strong><br />
</dt>
<dd>
<pre>
   Returns the time at which the song queue was last modified.
    
       This method is intended for use by GUI clients that don't want to waste time
       downloading the entire contents of the song queue if it hasn't changed.
       
       Arguments: None.
       Return value: A floating-point number that represents time as the number of
           seconds since the epoch.</pre>
</dd>
<dt><strong><a name="item_length">int <strong>length</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns the number of items in the song queue.
    
       Arguments: None.
       Return value: The number of items in the song queue.</pre>
</dd>
<dt><strong><a name="item_list">array <strong>list</strong> ()</a></strong><br />
</dt>
<dt><strong>array <strong>list</strong> (array)</strong><br />
</dt>
<dd>
<pre>
   Lists the song queue's contents. If a range is specified, only the
       items that fall within that range are listed.
    
       Arguments: Either none, or an array of integers that represents a range.
         * If no range is given, the whole list is returned.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: An array of (base64-encoded) strings, representing the
           selected range from the song queue's contents.</pre>
</dd>
<dt><strong><a name="item_move">boolean <strong>move</strong> (array, int)</a></strong><br />
</dt>
<dd>
<pre>
   Moves a range of items to a new position within the queue.
    
       Arguments: The first argument is an array of integers that represents a
           range of items to be moved. 
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
         * The second argument, &quot;destination&quot;, specifies the position in the queue
           where the items will be moved.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_move_list">boolean <strong>move_list</strong> (array, int)</a></strong><br />
</dt>
<dd>
<pre>
   Moves the items referenced by a list of positions to a new position.
       
       Arguments: The first argument is an array of integers that represents a
           list of the positions of the items to be moved. 
         * The second argument, &quot;destination&quot;, specifies the position in the queue
           where the items will be moved.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_next">boolean <strong>next</strong> ()</a></strong><br />
</dt>
<dt><strong>boolean <strong>next</strong> (int)</strong><br />
</dt>
<dd>
<pre>
   Stops the current song (if any), and jumps ahead to a song that is
       currently in the queue. The skipped songs are recorded in the history as if
       they had been played. When called without arguments, this behaves very
       much like the skip() method, except that it will have an effect even if
       nothing is currently playing.
    
       Arguments: A single integer that tells how far forward into the song queue
           to advance. A value of 1 will cause the first song in the queue to play,
           2 will cause the second song in the queue to play, and so on. If no
           argument is given, a value of 1 is assumed.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_no_op">boolean <strong>no_op</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Does nothing, successfully.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_pause">boolean <strong>pause</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Pauses the currently playing song.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_prepend">boolean <strong>prepend</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Adds items to the beginning of the queue.
    
       Argument: An array of (base64-encoded) strings, representing the items to be
           added.
         * When adding local filenames to the queue, only absolute pathnames should
           be used.  Using relative pathnames would be foolish because the server
           has no idea what the client's current working directory is.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_previous">boolean <strong>previous</strong> ()</a></strong><br />
</dt>
<dt><strong>boolean <strong>previous</strong> (int)</strong><br />
</dt>
<dd>
<pre>
   Stops the current song (if any), removes the most recently played song
       from the history, and puts these songs at the head of the queue. When loop
       mode is on, the songs at the tail of the song queue are used instead of the
       most recently played songs in the history.
    
       Arguments: A single integer that tells how far back in the history list to
           retreat. A value of 1 will cause the most recent song to play, 2 will
           cause the second most recent song to play, and so on. If no argument is
           given, a value of 1 is assumed.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_putback">boolean <strong>putback</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Places the currently playing song at the beginning of the queue.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_queue_length">int <strong>queue_length</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns the number of items in the song queue.
    
       Arguments: None.
       Return value: The number of items in the song queue.</pre>
</dd>
<dt><strong><a name="item_reconfigure">boolean <strong>reconfigure</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Tells the server to reread its player configuration file.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_remove">boolean <strong>remove</strong> (base64)</a></strong><br />
</dt>
<dt><strong>boolean <strong>remove</strong> (base64, array)</strong><br />
</dt>
<dd>
<pre>
   Removes all items that match the given regular expression.
    
       Arguments: A regular expression that specifies which items to remove.
         * Optionally, an array of integers may be given as a second argument.
           This argument represents a range to which the removal will be limited.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_replace">boolean <strong>replace</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Replaces the contents of the queue with the given items.
    
       This is equivalent to calling clear() and prepend() in succession, except that this
       operation is atomic.
    
       Argument: An array of (base64-encoded) strings, representing the items to be
           added.
         * When adding local filenames to the queue, only absolute pathnames
           should be used.  Using relative pathnames would be foolish because
           the server isn't aware of the client's current working directory.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_reverse">boolean <strong>reverse</strong> ()</a></strong><br />
</dt>
<dt><strong>boolean <strong>reverse</strong> (array)</strong><br />
</dt>
<dd>
<pre>
   Reverses the order of the items in the queue.
    
       Arguments: Either none, or an array of integers that represents a range.
         * If no range is given, the whole list is affected.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_run_queue">boolean <strong>run_queue</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Allows new songs to be played again after halt_queue() has been called.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_runqueue">boolean <strong>runqueue</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Allows new songs to be played again after halt_queue() has been called.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_set_history_limit">boolean <strong>set_history_limit</strong> (int)</a></strong><br />
</dt>
<dd>
<pre>
   Sets the limit on the size of the history list stored in memory.
    
       This will irrevocably discard history entries if the new limit is lower than
       the current size of the history list.
    
       Arguments: The new maximum number of history entries. If this value is
           negative, the history limit will be set to zero.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_set_loop_mode">boolean <strong>set_loop_mode</strong> (boolean)</a></strong><br />
</dt>
<dd>
<pre>
   Turns loop mode on or off.
    
       If loop mode is on, songs are returned to the end of the song queue after
       they finish playing.  If loop mode is off, songs that have finished playing
       are not returned to the queue.
    
       Arguments: True if you want to turn loop mode on, False if you want to turn
           it off.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_showconfig">base64 <strong>showconfig</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns a textual description of the server's player configuration.
    
       Arguments: None.
       Return value: A (base64-encoded) string that shows which programs will be
           used to play the various file-types recognized by the Moosic server.</pre>
</dd>
<dt><strong><a name="item_shuffle">boolean <strong>shuffle</strong> ()</a></strong><br />
</dt>
<dt><strong>boolean <strong>shuffle</strong> (array)</strong><br />
</dt>
<dd>
<pre>
   Rearrange the contents of the queue into a random order.
    
       Arguments: Either none, or an array of integers that represents a range.
         * If no range is given, the whole list is affected.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_skip">boolean <strong>skip</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Skips the rest of the current song to play the next song in the queue.
       This only has an effect if there actually is a current song.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_sort">boolean <strong>sort</strong> ()</a></strong><br />
</dt>
<dt><strong>boolean <strong>sort</strong> (array)</strong><br />
</dt>
<dd>
<pre>
   Arranges the contents of the queue into sorted order.
    
       Arguments: Either none, or an array of integers that represents a range.
         * If no range is given, the whole list is affected.
         * If the range contains a single integer, it will represent all members
           of the queue whose index is greater than or equal to the value of the
           integer.
         * If the range contains two integers, it will represent all members of
           the queue whose index is greater than or equal to the value of the
           first integer and less than the value of the second integer.
         * If the range contains more than two integers, an error will occur.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_stop">boolean <strong>stop</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Stops playing the current song and stops new songs from playing. The
       current song is returned to the head of the song queue and is not recorded
       in the history list. If loop mode is on, the current song won't be placed at
       the end of the song queue when it is stopped.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_sub">boolean <strong>sub</strong> (base64, base64)</a></strong><br />
</dt>
<dt><strong>boolean <strong>sub</strong> (base64, base64, array)</strong><br />
</dt>
<dd>
<pre>
   Performs a regular expression substitution on the items in the queue.
       
       Arguments: The first is a (base64-encoded) regular expression that specifies
           the text to be replaced.
         * The second argument is the (base64-encoded) string that will be used to
           replace the first occurrence of the regular expression within each queue
           item. Any backslash escapes in this string will be processed, including
           special character translation (e.g. &quot;\n&quot; to newline) and backreferences
           to groups within the match.
         * Optionally, an array of integers may be given as a third argument.
           This argument represents a range to which the substitution will be
           limited. This range is interpreted in the same way as the range argument
           in other Moosic methods.
         * If performing a replacement changes an item in the queue into the empty
           string, then it is removed from the queue.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_sub_all">boolean <strong>sub_all</strong> (base64, base64)</a></strong><br />
</dt>
<dt><strong>boolean <strong>sub_all</strong> (base64, base64, array)</strong><br />
</dt>
<dd>
<pre>
   Performs a global regular expression substitution on the items in the queue.
       
       Arguments: The first is a (base64-encoded) regular expression that specifies
           the text to be replaced.
         * The second argument is the (base64-encoded) string that will be used to
           replace all occurrences of the regular expression within each queue
           item. Any backslash escapes in this string will be processed, including
           special character translation (e.g. &quot;\n&quot; to newline) and backreferences
           to the substrings matched by individual groups in the pattern.
         * Optionally, an array of integers may be given as a third argument.
           This argument represents a range to which the substitution will be
           limited. This range is interpreted in the same way as the range argument
           in other Moosic methods.
         * If performing a replacement changes an item in the queue into the empty
           string, then it is removed from the queue.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_swap">boolean <strong>swap</strong> (array, array)</a></strong><br />
</dt>
<dd>
<pre>
   Swaps the items contained in one range with the items contained in the
       other range.
       
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_listmethods">array <strong>system.listMethods</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Return an array of all available XML-RPC methods on this server.</pre>
</dd>
<dt><strong><a name="item_methodhelp">string <strong>system.methodHelp</strong> (string)</a></strong><br />
</dt>
<dd>
<pre>
   Given the name of a method, return a help string.</pre>
</dd>
<dt><strong><a name="item_methodsignature">array <strong>system.methodSignature</strong> (string)</a></strong><br />
</dt>
<dd>
<pre>
   Given the name of a method, return an array of legal signatures. Each
           signature is an array of strings. The first item of each signature is
           the return type, and any others items are parameter types.</pre>
</dd>
<dt><strong><a name="item_multicall">array <strong>system.multicall</strong> (array)</a></strong><br />
</dt>
<dd>
<pre>
   Process an array of calls, and return an array of results. Calls
           should be structs of the form {'methodName': string, 'params': array}.
           Each result will either be a single-item array containing the result
           value, or a struct of the form {'faultCode': int, 'faultString':
           string}. This is useful when you need to make lots of small calls
           without lots of round trips.</pre>
</dd>
<dt><strong><a name="item_toggle_loop_mode">boolean <strong>toggle_loop_mode</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Turns loop mode on if it is off, and turns it off if it is on.
    
       If loop mode is on, songs are returned to the end of the song queue after
       they finish playing.  If loop mode is off, songs that have finished playing
       are not returned to the queue.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_toggle_pause">boolean <strong>toggle_pause</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Pauses the current song if it is playing, and unpauses if it is paused.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_unpause">boolean <strong>unpause</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Unpauses the current song.
    
       Arguments: None.
       Return value: Nothing meaningful.</pre>
</dd>
<dt><strong><a name="item_version">string <strong>version</strong> ()</a></strong><br />
</dt>
<dd>
<pre>
   Returns the Moosic server's version string.
    
       Arguments: None.
       Return value: The version string for the Moosic server.</pre>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="section_4__writing_a_moosic_client_in_python">Section 4: Writing a Moosic Client in Python</a></h1>
<p>As demonstrated in section 0, communicating with a Moosic server is very easy to
do with Python.  In this section, I'll merely elaborate on the details that were
omitted from section 0 for the sake of brevity.</p>
<p>First of all, you should know that <code>LocalMoosicProxy()</code> can be called with a
filename argument to specify the location of the Moosic server's socket file.
This is useful if moosicd was started with the ``-c'' option.  Refer to the
moosic_factory.py module's documentation (moosic_factory.html).</p>
<p>Next, note that many of the Moosic server's methods accept or return special
types of objects from the xmlrpclib module, namely Boolean and Binary.  These
object types serve the purpose of bridging the small mismatch between the
data-types supported by XML-RPC and Python's intrinsic data-types.  Boolean
objects present no unusual problem, since they evaluate to a correct truth value
without any extra effort.  However, you must take care when using the Moosic
methods that accept or return Binary objects.  Read the documentation for the
xmlrpclib module for details on how to work with these objects.  The basic
technique boils down to wrapping up a string inside a Binary object before
sending it to the server, and using the ``data'' attribute to access the string
data within the Binary objects returned by the server.  Regular strings can't be
used because XML-RPC's normal string data-type can't handle multiple 8-bit
strings within a single request if the strings use different encodings.</p>
<p>
</p>
<hr />
<h1><a name="section_5__writing_a_moosic_client_in_another_language">Section 5: Writing a Moosic Client in Another Language</a></h1>
<p>If you are not using Python to write your Moosic client, the first issue to deal
with is deciding upon an XML-RPC implementation.  For most popular programming
languages, there are multiple XML-RPC implementations available.  Most of the
possibilities are listed at
<a href="http://www.xmlrpc.com/directory/1568/implementations">http://www.xmlrpc.com/directory/1568/implementations</a>.  Since XML-RPC is an
open specification, you can create your own implementation if you don't like any
of the ones that already exist.</p>
<p>Once you've got an XML-RPC library that you like, the big hurdle to overcome is
to make that library send its RPC calls over a Unix socket instead of an IP
socket.  I was able to do this pretty easily with Python's xmlrpclib since it is
designed to allow pluggable transport methods:  all I had to do was subclass my
own Transport type and plug it back into the original library's classes.  (If
your language and/or library of choice makes this task difficult, then you may
begin to understand why some Python programmers are so smug.)</p>
<p>After you are capable of sending XML-RPC requests through a Unix socket, you can
go ahead and start sending requests to a Moosic server.  Refer to the end of
section 2 for information on how to address a Moosic server.  Refer to section 3
for a list of valid server requests.</p>
<p>If you can't be bothered to find or hack together an XML-RPC library that works
with Unix sockets, then you can still talk to a Moosic server that is listening
on an IP socket, but this is less than ideal since listening on an IP socket is
not default behavior for most Moosic servers.</p>
<p>
</p>
<hr />
<h1><a name="section_6__api_version_history__changelog_">Section 6: API Version History (ChangeLog)</a></h1>
<ul>
<li><strong><a name="item_1_2e8">1.8</a></strong><br />
</li>
First implemented in moosicd 1.5.1. The following methods were added:
<pre>
    swap</pre>
<p></p>
<li><strong><a name="item_1_2e7">1.7</a></strong><br />
</li>
First implemented by moosicd 1.5.0. The following methods were added:
<pre>
    skip, current_time</pre>
<p>The following methods had their behavior significantly changed:</p>
<pre>
    previous, next</pre>
<p>Specifically, the <a href="#item_previous"><code>previous()</code></a> method no longer activates queue advancement if it
had been disabled before.  This means that calling <a href="#item_previous"><code>previous()</code></a> no longer
necessarily causes a song to start playing.  The <a href="#item_next"><code>next()</code></a> method was changed to
more closely parallel the behavior of previous(): it takes a single optional
integer argument to allow immediate advancement by more than one song at a time,
and it has an effect even when no song is currently playing.  The new <a href="#item_skip"><code>skip()</code></a>
method implements the exact same behavior that was previously exhibited by
next().</p>
<p>Last, and most importantly, the name of the default socket file for
communicating with the server via unix sockets was changed from
$CONFIG_DIR/socket-$HOSTNAME to $CONFIG_DIR/socket.  If you are a Python
programmer and you use the updated moosic_factory.py file from Moosic version
1.5.0, then you don't have to make any changes.  Otherwise, you must change your
client's code to connect to the file named ``socket'' instead of the file named
``socket-something.example.com''.  If your client only talks to the Moosic server
through TCP/IP, then you don't have to make any changes, of course.</p>
<p></p>
<li><strong><a name="item_1_2e6">1.6</a></strong><br />
</li>
First implemented by moosicd 1.4.10. The following methods were added:
<pre>
    getconfig</pre>
<p></p>
<li><strong><a name="item_1_2e5">1.5</a></strong><br />
</li>
First implemented by moosicd 1.4.6. The following methods were added:
<pre>
    sub, sub_all, stop</pre>
<p></p>
<li><strong><a name="item_1_2e4">1.4</a></strong><br />
</li>
First implemented by moosicd 1.4.5. The following methods were added:
<pre>
    previous</pre>
<p></p>
<li><strong><a name="item_1_2e3">1.3</a></strong><br />
</li>
First implemented by moosicd 1.4.4. The following methods were added:
<pre>
    replace, replace_range, last_queue_update</pre>
<p></p>
<li><strong><a name="item_1_2e2">1.2</a></strong><br />
</li>
First implemented by moosicd 1.4.2. The following methods were added:
<pre>
    cut_list, crop_list</pre>
<p></p>
<li><strong><a name="item_1_2e1">1.1</a></strong><br />
</li>
First implemented by moosicd 1.4.1. The following methods were added:
<pre>
    is_looping, set_loop_mode, toggle_loop_mode</pre>
<p></p>
<li><strong><a name="item_1_2e0">1.0</a></strong><br />
</li>
First implemented by moosicd 1.4.0. The following methods were included:
<pre>
    api_version, append, clear, crop, current, cut, die, filter,
    get_history_limit, halt_queue, haltqueue, history, indexed_list, insert,
    is_paused, is_queue_running, length, list, move, move_list, next, no_op,
    pause, prepend, putback, queue_length, reconfigure, remove, reverse,
    run_queue, runqueue, set_history_limit, showconfig, shuffle, sort,
    system.listMethods, system.methodHelp, system.methodSignature,
    system.multicall, toggle_pause, unpause, version</pre>
<p></p></ul>

</body>

</html>
