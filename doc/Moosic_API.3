.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Moosic_API 3"
.TH Moosic_API 3 "2005-08-16" "Moosic 1.5.2" ""
.SH "NAME"
Moosic_API \- How to write your own Moosic client.
.SH "Introduction"
.IX Header "Introduction"
\&\*(L"moosicd\*(R" is a program that implements the server portion of the Moosic jukebox
system.  This server provides services for manipulating a queue of songs to be
played, as well as for controlling the playing of these songs.  A Moosic client
sends requests to the server, and receives data in response to these requests.
The \*(L"moosic\*(R" command line utility is the canonical Moosic client, and provides
a way to control a Moosic server from an interactive command shell or from a
shell script.  However, you might not be satisfied by the interface that is
provided by the \*(L"moosic\*(R" command, so I have written this document to describe
how to communicate with a Moosic server in your own programs.
.PP
[This document was written by Daniel Pearson <daniel@nanoo.org>, and has
been placed into the public domain.]
.SH "Section 0: Instructions for Impatient Developers"
.IX Header "Section 0: Instructions for Impatient Developers"
.IP "1." 4
Plan to write your program with Python and xmlrpclib. xmlrpclib is included with
Python 2.2 or later, but if you need to use an earlier version of Python,
xmlrpclib can be downloaded from <http://www.pythonware.com/products/xmlrpc/>.
.IP "2." 4
If you can't or don't want to write your program with Python and xmlrpclib, you
won't benefit from this section and will have to read section 2 of this
document.
.IP "3." 4
Create a proxy which communicates with moosicd:
.Sp
.Vb 2
\&   >>> import moosic.client.factory
\&   >>> proxy = moosic.client.factory.LocalMoosicProxy()
.Ve
.IP "4." 4
Read section 3 for the documentation of all the methods supported by the proxy
object.
.IP "5." 4
Use the proxy to get information from the server and to send commands to it.
For example:
.Sp
.Vb 27
\&   >>> proxy.list()
\&   []
\&   >>> proxy.is_queue_running()
\&   True
\&   >>> proxy.haltqueue()
\&   True
\&   >>> proxy.is_queue_running()
\&   False
\&   >>> proxy.append([xmlrpc.Binary(i) for i in 
\&   ...       ['/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3',
\&   ...        '/home/daniel/music/Fiona_Apple/When_The_Pawn/04\-Love_Ridden.ogg',
\&   ...        "/home/daniel/music/Zelda/Great_Fairy's_Fountain.mid"]])
\&   True
\&   >>> proxy.list()
\&   [<xmlrpclib.Binary instance at 0x843cf3c>,
\&    <xmlrpclib.Binary instance at 0x8440e94>,
\&    <xmlrpclib.Binary instance at 0x8440ebc>]
\&   >>> [i.data for i in proxy.list()]
\&   ['/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3',
\&    '/home/daniel/music/Fiona_Apple/When_The_Pawn/04\-Love_Ridden.ogg',
\&    "/home/daniel/music/Zelda/Great_Fairy's_Fountain.mid"]
\&   >>> proxy.sort()
\&   True
\&   >>> [i.data for i in proxy.list()]
\&   ['/home/daniel/music/Fiona_Apple/When_The_Pawn/04\-Love_Ridden.ogg',
\&    '/home/daniel/music/Weird_Al/Pretty_Fly_for_a_Rabbi.mp3',
\&    "/home/daniel/music/Zelda/Great_Fairy's_Fountain.mid"]
.Ve
.IP "6." 4
If you wish to communicate with a moosicd that is listening for requests on
an \s-1IP\s0 socket instead of a Unix domain socket, you should use InetMoosicProxy
instead of LocalMoosicProxy.  Here's an example:
.Sp
.Vb 2
\&   >>> import moosic.client.factory
\&   >>> proxy = moosic.client.factory.InetMoosicProxy('example.com', 8080)
.Ve
.SH "Section 1: The Moosic Server's Data Model"
.IX Header "Section 1: The Moosic Server's Data Model"
This section describes, in precise terms, the data objects that can be accessed
and manipulated by sending requests to the Moosic server.
.IP "song queue" 4
.IX Item "song queue"
This is the foremost data object maintained by the Moosic server. It is an
ordered sequence of strings that represents the queue of songs that are waiting
to be played.  Each item in this list identifies a song that will be played by
the Moosic server.  Usually, these items are the names of files on disk that
contain each song, but this does not have to be the case.  For instance, an \s-1HTTP\s0
\&\s-1URL\s0 might be used to name a song if a program that can play songs from the Web
is appropriately registered with the Moosic server (see \*(L"player configuration\*(R"
later in this section).
.IP "current song" 4
.IX Item "current song"
This is a string that identifies the song that is currently being played by the
Moosic server.  If nothing is currently playing, then this will be the empty
string.
.IP "queue running flag" 4
.IX Item "queue running flag"
This is a boolean value that indicates whether the Moosic server will start
playing a new song as soon as the current song has finished and the song queue
is not empty.
.IP "pause flag" 4
.IX Item "pause flag"
This is a boolean value that indicates whether the current song is paused or
not.
.IP "loop mode flag" 4
.IX Item "loop mode flag"
This is a boolean value that sets \*(L"loop mode\*(R".  When loop mode is on, songs are
returned to the end of the song queue when they finish playing instead of being
discarded.
.IP "history" 4
.IX Item "history"
This is a list of songs that the Moosic server has finished playing.  Note that
songs named in this list may have finished playing early at the request of a
user (i.e. through use of the \*(L"next\*(R" command).  Each entry in this list is
actually a 3\-tuple of (song, start time, finish time).
.IP "maximum history size" 4
.IX Item "maximum history size"
This is the maximum number of songs that will be stored in the history list.
Old entries are removed from the history to make room for newer entries when
this limit is reached.
.IP "player configuration" 4
.IX Item "player configuration"
This is an ordered mapping that associates regular expressions (text patterns)
to programs.  For each regular expression, the associated program is expected to
be able to play any queue items that match that regular expression.  Each
program is a list in which the name of the executable file that contains the
program is the first element and the program's arguments are the rest of the
elements.
.IP "last queue update" 4
.IX Item "last queue update"
This is the time at which the song queue was last modified.  It a floating-point
number that represents time as the number of seconds since the epoch.
.IP "server version" 4
.IX Item "server version"
This is a string that describes the version of the program that implements the
Moosic server.  It has no specific, well-defined semantics.
.IP "\s-1API\s0 version" 4
.IX Item "API version"
This is a pair of integers, one representing the \*(L"major\*(R" version, and the other
representing the \*(L"minor\*(R" version.  These numbers are meant to provide some
useful compatibility information to Moosic clients.  As this \s-1API\s0 changes, these
numbers will change in the following ways.  If the \s-1API\s0 has been changed in a
backward-compatible way (e.g. a new method was added or an existing method was
overloaded), then the minor version will increase and the major version will
remain unchanged.  However, if the \s-1API\s0 has been changed in such a way that
existing code that uses the \s-1API\s0 might break (e.g.  a method was removed or its
return value or parameter types were changed), then the major version will
increase and the minor version may be reset to any value (although it will
usually be reset zero).
.SH "Section 2: The Low-Level Details of Client-Server Communication"
.IX Header "Section 2: The Low-Level Details of Client-Server Communication"
The information in this section is generally only necessary to people who wish
to write a Moosic client in a programming language other than Python.  If you
are using Python to write a Moosic client, then you can use the classes
LocalMoosicProxy and InetMoosicProxy from the moosic_factory.py module, and
blissfully ignore most of these gory details.  However, Python programmers can
also benefit from reading this section, as it will deepen their understanding of
Moosic's inter-process communication model.
.PP
The first thing to know about writing your own Moosic client is that
communication between the client and server is done through a BSD-style socket.
Read the \*(L"socket\*(R" manual page (and related manual pages) on a Unix system if you
are unfamiliar with \s-1BSD\s0 sockets.  The socket used by Moosic belongs to the
Unix-domain protocol family (\s-1PF_UNIX\s0 or \s-1PF_LOCAL\s0) and has a type of \s-1SOCK_STREAM\s0.
This means that a Moosic client can only communicate with a Moosic server that
is running on the same computer as the client.  This limitation is a very
purposeful part of Moosic's design.  It has the advantage of vastly reducing the
consequences of any security flaws that Moosic might have.
.PP
If you really, really think that you need the client and the server to run on
separate hosts, then you can run moosicd with the \-t option, which tells it to
listen on a \s-1TCP/IP\s0 socket instead of a Unix domain socket.  I recommend
firewalling such a port very carefully.
.PP
Regardless of which kind of socket is used by the server, XML-RPC is used as the
data protocol for requests and responses.  For an introduction to \s-1XML\-RPC\s0, see
the XML-RPC homepage <http://www.xmlrpc.com/> and the XML-RPC \s-1HOWTO\s0
<http://xmlrpc\-c.sourceforge.net/xmlrpc\-howto/xmlrpc\-howto.html>.  Python users
should note that if the XML-RPC \s-1HOWTO\s0 tells you that you need to install a
third-party library to use \s-1XML\-RPC\s0, it is assuming that you are using a Python
version earlier than 2.2.  Since version 2.2, Python has included the xmlrpclib
module in its standard library.
.PP
In summary, all you need to do to talk to a Moosic server in your own program is
to send XML-RPC requests to the appropriate address.  By default, the
appropriate address for contacting moosicd is the file named \*(L"socket\*(R" in a
directory named \*(L".moosic\*(R" in the home directory of the user that started moosicd
(i.e. \*(L"~/.moosic/socket\*(R").  If moosicd is started with the \-c option, then the
directory that contains \*(L"socket\*(R" will be the argument provided to the \-c option
instead of ~/.moosic.  If moosicd is started with the \-t option, then clients
will have to address it by using a (host, port) pair instead of a filename.
.SH "Section 3: Valid Moosic Server Methods"
.IX Header "Section 3: Valid Moosic Server Methods"
moosicd's XML-RPC server implements the introspection \s-1API\s0 mentioned on
<http://xmlrpc\-c.sourceforge.net/xmlrpc\-howto/xmlrpc\-howto\-api\-introspection.html>,
so the \s-1API\s0 presented by moosicd is essentially self\-documenting.  Thus, the
information in this section has been automatically generated by querying a
running Moosic server.
.PP
The Moosic \s-1API\s0 contains the following methods:
.IP "array \fBapi_version\fR ()" 4
.IX Item "array api_version ()"
.Vb 1
\&   Returns the version number for the API that the server implements.
.Ve
.Sp
.Vb 4
\&       Arguments: None.
\&       Return value: The version number, which is a 2\-element array of
\&           integers.  The first element is the major version, and the second
\&           element is the minor version.
.Ve
.IP "boolean \fBappend\fR (array)" 4
.IX Item "boolean append (array)"
.Vb 1
\&   Adds items to the end of the queue.
.Ve
.Sp
.Vb 6
\&       Argument: An array of (base64\-encoded) strings, representing the items to be
\&           added.
\&         * When adding local filenames to the queue, only absolute pathnames should
\&           be used.  Using relative pathnames would be foolish because the server
\&           has no idea what the client's current working directory is.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBclear\fR ()" 4
.IX Item "boolean clear ()"
.Vb 1
\&   Removes all items from the queue.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBcrop\fR (array)" 4
.IX Item "boolean crop (array)"
.Vb 1
\&   Remove all queued items that do not fall within the given range.
.Ve
.Sp
.Vb 9
\&       Arguments: An array of integers that represents a range.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBcrop_list\fR (array)" 4
.IX Item "boolean crop_list (array)"
.Vb 1
\&   Removes all items except for those referenced by a list of positions.
.Ve
.Sp
.Vb 3
\&       Arguments: An array of integers that represents a list of the positions of
\&           the items to be kept. 
\&       Return value: Nothing meaningful.
.Ve
.IP "base64 \fBcurrent\fR ()" 4
.IX Item "base64 current ()"
.Vb 1
\&   Returns the name of the currently playing song.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: The name of the currently playing song.
.Ve
.IP "double \fBcurrent_time\fR ()" 4
.IX Item "double current_time ()"
.Vb 1
\&   Returns the amount of time that the current song has been playing.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: The number of seconds that the current song has been playing.
.Ve
.IP "boolean \fBcut\fR (array)" 4
.IX Item "boolean cut (array)"
.Vb 1
\&   Remove all queued items that fall within the given range.
.Ve
.Sp
.Vb 9
\&       Arguments: An array of integers that represents a range.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBcut_list\fR (array)" 4
.IX Item "boolean cut_list (array)"
.Vb 1
\&   Removes the items referenced by a list of positions within the queue.
.Ve
.Sp
.Vb 3
\&       Arguments: An array of integers that represents a list of the positions of
\&           the items to be removed. 
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBdie\fR ()" 4
.IX Item "boolean die ()"
.Vb 1
\&   Tells the server to terminate itself.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBfilter\fR (base64)" 4
.IX Item "boolean filter (base64)"
.PD 0
.IP "boolean \fBfilter\fR (base64, array)" 4
.IX Item "boolean filter (base64, array)"
.PD
.Vb 1
\&   Removes all items that don't match the given regular expression.
.Ve
.Sp
.Vb 12
\&       Arguments: A regular expression that specifies which items to keep.
\&         * Optionally, an array of integers may be given as a second argument.
\&           This argument represents a range to which the filtering will be
\&           limited.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "int \fBget_history_limit\fR ()" 4
.IX Item "int get_history_limit ()"
.Vb 1
\&   Gets the limit on the size of the history list stored in memory.
.Ve
.Sp
.Vb 3
\&       Arguments: None.
\&       Return value: The maximum number of history entries that the server will
\&           remember.
.Ve
.IP "array \fBgetconfig\fR ()" 4
.IX Item "array getconfig ()"
.Vb 1
\&   Returns a list of the server's filetype\-player associations.
.Ve
.Sp
.Vb 6
\&       Arguments: None.
\&       Return value: An array of pairs. The first element of each pair is a
\&           (base64\-encoded) string that represents a regular expression pattern,
\&           and the second element is a (base64\-encoded) string that represents the
\&           system command that should be used to handle songs that match the
\&           corresponding pattern.
.Ve
.IP "boolean \fBhalt_queue\fR ()" 4
.IX Item "boolean halt_queue ()"
.Vb 2
\&   Stops any new songs from being played. Use run_queue() to reverse this
\&       state.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBhaltqueue\fR ()" 4
.IX Item "boolean haltqueue ()"
.Vb 2
\&   Stops any new songs from being played. Use run_queue() to reverse this
\&       state.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "array \fBhistory\fR ()" 4
.IX Item "array history ()"
.PD 0
.IP "array \fBhistory\fR (int)" 4
.IX Item "array history (int)"
.PD
.Vb 1
\&   Returns a list of the items that were recently played.
.Ve
.Sp
.Vb 15
\&       Arguments: If a positive integer argument is given, then no more than that
\&           number of entries will be returned.  If a number is not specified, or if
\&           zero is given, then the entire history is returned.  The result is
\&           undefined if a negative integer argument is given (but does not raise an
\&           exception).
\&       Return value: An array of triples, each representing a song that was played
\&           along with the times that it started and finished playing.
\&         * The first member of the pair is a (base64\-encoded) string which
\&           represents the song that was previously played.
\&         * The second member of the pair is a floating point number which
\&           represents the time that the song started playing in seconds since the
\&           epoch.
\&         * The third member of the pair is a floating point number which
\&           represents the time that the song finished playing in seconds since the
\&           epoch.
.Ve
.IP "struct \fBindexed_list\fR ()" 4
.IX Item "struct indexed_list ()"
.PD 0
.IP "struct \fBindexed_list\fR (array)" 4
.IX Item "struct indexed_list (array)"
.PD
.Vb 2
\&   Lists the song queue's contents. If a range is specified, only the
\&       items that fall within that range are listed.
.Ve
.Sp
.Vb 4
\&       This differs from list() only in its return value, and is useful when you
\&       want to know the starting position of your selected range within the song
\&       queue (which can be different than the starting index of the specified range
\&       if, for example, the starting index is a negative integer).
.Ve
.Sp
.Vb 14
\&       Arguments: Either none, or an array of integers that represents a range.
\&         * If no range is given, the whole list is returned.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: A struct with two elements. This first is "list", an array of
\&           (base64\-encoded) strings, representing the selected range from the song
\&           queue's contents. The second is "start", an integer index value that
\&           represents the position of the first item of the returned list in the
\&           song queue.
.Ve
.IP "boolean \fBinsert\fR (array, int)" 4
.IX Item "boolean insert (array, int)"
.Vb 1
\&   Inserts items at a given position in the queue.
.Ve
.Sp
.Vb 8
\&       Arguments: The first argument is an array of (base64\-encoded) strings,
\&           representing the items to be added.
\&         * The second argument specifies the position in the queue where the items
\&           will be inserted.
\&         * When adding local filenames to the queue, only absolute pathnames should
\&           be used.  Using relative pathnames would be foolish because the server
\&           has no idea what the client's current working directory is.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBis_looping\fR ()" 4
.IX Item "boolean is_looping ()"
.Vb 1
\&   Tells you whether loop mode is on or not.
.Ve
.Sp
.Vb 3
\&       If loop mode is on, songs are returned to the end of the song queue after
\&       they finish playing.  If loop mode is off, songs that have finished playing
\&       are not returned to the queue.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: True if loop mode is set, False if it is not.
.Ve
.IP "boolean \fBis_paused\fR ()" 4
.IX Item "boolean is_paused ()"
.Vb 1
\&   Tells you whether the current song is paused or not.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: True if the current song is paused, otherwise False.
.Ve
.IP "boolean \fBis_queue_running\fR ()" 4
.IX Item "boolean is_queue_running ()"
.Vb 1
\&   Tells you whether the queue consumption (advancement) is activated.
.Ve
.Sp
.Vb 3
\&       Arguments: None.
\&       Return value: True if new songs are going to be played from the queue after
\&           the current song is finished, otherwise False.
.Ve
.IP "double \fBlast_queue_update\fR ()" 4
.IX Item "double last_queue_update ()"
.Vb 1
\&   Returns the time at which the song queue was last modified.
.Ve
.Sp
.Vb 2
\&       This method is intended for use by GUI clients that don't want to waste time
\&       downloading the entire contents of the song queue if it hasn't changed.
.Ve
.Sp
.Vb 3
\&       Arguments: None.
\&       Return value: A floating\-point number that represents time as the number of
\&           seconds since the epoch.
.Ve
.IP "int \fBlength\fR ()" 4
.IX Item "int length ()"
.Vb 1
\&   Returns the number of items in the song queue.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: The number of items in the song queue.
.Ve
.IP "array \fBlist\fR ()" 4
.IX Item "array list ()"
.PD 0
.IP "array \fBlist\fR (array)" 4
.IX Item "array list (array)"
.PD
.Vb 2
\&   Lists the song queue's contents. If a range is specified, only the
\&       items that fall within that range are listed.
.Ve
.Sp
.Vb 11
\&       Arguments: Either none, or an array of integers that represents a range.
\&         * If no range is given, the whole list is returned.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: An array of (base64\-encoded) strings, representing the
\&           selected range from the song queue's contents.
.Ve
.IP "boolean \fBmove\fR (array, int)" 4
.IX Item "boolean move (array, int)"
.Vb 1
\&   Moves a range of items to a new position within the queue.
.Ve
.Sp
.Vb 12
\&       Arguments: The first argument is an array of integers that represents a
\&           range of items to be moved. 
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&         * The second argument, "destination", specifies the position in the queue
\&           where the items will be moved.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBmove_list\fR (array, int)" 4
.IX Item "boolean move_list (array, int)"
.Vb 1
\&   Moves the items referenced by a list of positions to a new position.
.Ve
.Sp
.Vb 5
\&       Arguments: The first argument is an array of integers that represents a
\&           list of the positions of the items to be moved. 
\&         * The second argument, "destination", specifies the position in the queue
\&           where the items will be moved.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBnext\fR ()" 4
.IX Item "boolean next ()"
.PD 0
.IP "boolean \fBnext\fR (int)" 4
.IX Item "boolean next (int)"
.PD
.Vb 5
\&   Stops the current song (if any), and jumps ahead to a song that is
\&       currently in the queue. The skipped songs are recorded in the history as if
\&       they had been played. When called without arguments, this behaves very
\&       much like the skip() method, except that it will have an effect even if
\&       nothing is currently playing.
.Ve
.Sp
.Vb 5
\&       Arguments: A single integer that tells how far forward into the song queue
\&           to advance. A value of 1 will cause the first song in the queue to play,
\&           2 will cause the second song in the queue to play, and so on. If no
\&           argument is given, a value of 1 is assumed.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBno_op\fR ()" 4
.IX Item "boolean no_op ()"
.Vb 1
\&   Does nothing, successfully.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBpause\fR ()" 4
.IX Item "boolean pause ()"
.Vb 1
\&   Pauses the currently playing song.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBprepend\fR (array)" 4
.IX Item "boolean prepend (array)"
.Vb 1
\&   Adds items to the beginning of the queue.
.Ve
.Sp
.Vb 6
\&       Argument: An array of (base64\-encoded) strings, representing the items to be
\&           added.
\&         * When adding local filenames to the queue, only absolute pathnames should
\&           be used.  Using relative pathnames would be foolish because the server
\&           has no idea what the client's current working directory is.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBprevious\fR ()" 4
.IX Item "boolean previous ()"
.PD 0
.IP "boolean \fBprevious\fR (int)" 4
.IX Item "boolean previous (int)"
.PD
.Vb 4
\&   Stops the current song (if any), removes the most recently played song
\&       from the history, and puts these songs at the head of the queue. When loop
\&       mode is on, the songs at the tail of the song queue are used instead of the
\&       most recently played songs in the history.
.Ve
.Sp
.Vb 5
\&       Arguments: A single integer that tells how far back in the history list to
\&           retreat. A value of 1 will cause the most recent song to play, 2 will
\&           cause the second most recent song to play, and so on. If no argument is
\&           given, a value of 1 is assumed.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBputback\fR ()" 4
.IX Item "boolean putback ()"
.Vb 1
\&   Places the currently playing song at the beginning of the queue.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "int \fBqueue_length\fR ()" 4
.IX Item "int queue_length ()"
.Vb 1
\&   Returns the number of items in the song queue.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: The number of items in the song queue.
.Ve
.IP "boolean \fBreconfigure\fR ()" 4
.IX Item "boolean reconfigure ()"
.Vb 1
\&   Tells the server to reread its player configuration file.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBremove\fR (base64)" 4
.IX Item "boolean remove (base64)"
.PD 0
.IP "boolean \fBremove\fR (base64, array)" 4
.IX Item "boolean remove (base64, array)"
.PD
.Vb 1
\&   Removes all items that match the given regular expression.
.Ve
.Sp
.Vb 11
\&       Arguments: A regular expression that specifies which items to remove.
\&         * Optionally, an array of integers may be given as a second argument.
\&           This argument represents a range to which the removal will be limited.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBreplace\fR (array)" 4
.IX Item "boolean replace (array)"
.Vb 1
\&   Replaces the contents of the queue with the given items.
.Ve
.Sp
.Vb 2
\&       This is equivalent to calling clear() and prepend() in succession, except that this
\&       operation is atomic.
.Ve
.Sp
.Vb 6
\&       Argument: An array of (base64\-encoded) strings, representing the items to be
\&           added.
\&         * When adding local filenames to the queue, only absolute pathnames
\&           should be used.  Using relative pathnames would be foolish because
\&           the server isn't aware of the client's current working directory.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBreverse\fR ()" 4
.IX Item "boolean reverse ()"
.PD 0
.IP "boolean \fBreverse\fR (array)" 4
.IX Item "boolean reverse (array)"
.PD
.Vb 1
\&   Reverses the order of the items in the queue.
.Ve
.Sp
.Vb 10
\&       Arguments: Either none, or an array of integers that represents a range.
\&         * If no range is given, the whole list is affected.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBrun_queue\fR ()" 4
.IX Item "boolean run_queue ()"
.Vb 1
\&   Allows new songs to be played again after halt_queue() has been called.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBrunqueue\fR ()" 4
.IX Item "boolean runqueue ()"
.Vb 1
\&   Allows new songs to be played again after halt_queue() has been called.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBset_history_limit\fR (int)" 4
.IX Item "boolean set_history_limit (int)"
.Vb 1
\&   Sets the limit on the size of the history list stored in memory.
.Ve
.Sp
.Vb 2
\&       This will irrevocably discard history entries if the new limit is lower than
\&       the current size of the history list.
.Ve
.Sp
.Vb 3
\&       Arguments: The new maximum number of history entries. If this value is
\&           negative, the history limit will be set to zero.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBset_loop_mode\fR (boolean)" 4
.IX Item "boolean set_loop_mode (boolean)"
.Vb 1
\&   Turns loop mode on or off.
.Ve
.Sp
.Vb 3
\&       If loop mode is on, songs are returned to the end of the song queue after
\&       they finish playing.  If loop mode is off, songs that have finished playing
\&       are not returned to the queue.
.Ve
.Sp
.Vb 3
\&       Arguments: True if you want to turn loop mode on, False if you want to turn
\&           it off.
\&       Return value: Nothing meaningful.
.Ve
.IP "base64 \fBshowconfig\fR ()" 4
.IX Item "base64 showconfig ()"
.Vb 1
\&   Returns a textual description of the server's player configuration.
.Ve
.Sp
.Vb 3
\&       Arguments: None.
\&       Return value: A (base64\-encoded) string that shows which programs will be
\&           used to play the various file\-types recognized by the Moosic server.
.Ve
.IP "boolean \fBshuffle\fR ()" 4
.IX Item "boolean shuffle ()"
.PD 0
.IP "boolean \fBshuffle\fR (array)" 4
.IX Item "boolean shuffle (array)"
.PD
.Vb 1
\&   Rearrange the contents of the queue into a random order.
.Ve
.Sp
.Vb 10
\&       Arguments: Either none, or an array of integers that represents a range.
\&         * If no range is given, the whole list is affected.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBskip\fR ()" 4
.IX Item "boolean skip ()"
.Vb 2
\&   Skips the rest of the current song to play the next song in the queue.
\&       This only has an effect if there actually is a current song.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBsort\fR ()" 4
.IX Item "boolean sort ()"
.PD 0
.IP "boolean \fBsort\fR (array)" 4
.IX Item "boolean sort (array)"
.PD
.Vb 1
\&   Arranges the contents of the queue into sorted order.
.Ve
.Sp
.Vb 10
\&       Arguments: Either none, or an array of integers that represents a range.
\&         * If no range is given, the whole list is affected.
\&         * If the range contains a single integer, it will represent all members
\&           of the queue whose index is greater than or equal to the value of the
\&           integer.
\&         * If the range contains two integers, it will represent all members of
\&           the queue whose index is greater than or equal to the value of the
\&           first integer and less than the value of the second integer.
\&         * If the range contains more than two integers, an error will occur.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBstop\fR ()" 4
.IX Item "boolean stop ()"
.Vb 4
\&   Stops playing the current song and stops new songs from playing. The
\&       current song is returned to the head of the song queue and is not recorded
\&       in the history list. If loop mode is on, the current song won't be placed at
\&       the end of the song queue when it is stopped.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBsub\fR (base64, base64)" 4
.IX Item "boolean sub (base64, base64)"
.PD 0
.IP "boolean \fBsub\fR (base64, base64, array)" 4
.IX Item "boolean sub (base64, base64, array)"
.PD
.Vb 1
\&   Performs a regular expression substitution on the items in the queue.
.Ve
.Sp
.Vb 14
\&       Arguments: The first is a (base64\-encoded) regular expression that specifies
\&           the text to be replaced.
\&         * The second argument is the (base64\-encoded) string that will be used to
\&           replace the first occurrence of the regular expression within each queue
\&           item. Any backslash escapes in this string will be processed, including
\&           special character translation (e.g. "\en" to newline) and backreferences
\&           to groups within the match.
\&         * Optionally, an array of integers may be given as a third argument.
\&           This argument represents a range to which the substitution will be
\&           limited. This range is interpreted in the same way as the range argument
\&           in other Moosic methods.
\&         * If performing a replacement changes an item in the queue into the empty
\&           string, then it is removed from the queue.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBsub_all\fR (base64, base64)" 4
.IX Item "boolean sub_all (base64, base64)"
.PD 0
.IP "boolean \fBsub_all\fR (base64, base64, array)" 4
.IX Item "boolean sub_all (base64, base64, array)"
.PD
.Vb 1
\&   Performs a global regular expression substitution on the items in the queue.
.Ve
.Sp
.Vb 14
\&       Arguments: The first is a (base64\-encoded) regular expression that specifies
\&           the text to be replaced.
\&         * The second argument is the (base64\-encoded) string that will be used to
\&           replace all occurrences of the regular expression within each queue
\&           item. Any backslash escapes in this string will be processed, including
\&           special character translation (e.g. "\en" to newline) and backreferences
\&           to the substrings matched by individual groups in the pattern.
\&         * Optionally, an array of integers may be given as a third argument.
\&           This argument represents a range to which the substitution will be
\&           limited. This range is interpreted in the same way as the range argument
\&           in other Moosic methods.
\&         * If performing a replacement changes an item in the queue into the empty
\&           string, then it is removed from the queue.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBswap\fR (array, array)" 4
.IX Item "boolean swap (array, array)"
.Vb 2
\&   Swaps the items contained in one range with the items contained in the
\&       other range.
.Ve
.Sp
.Vb 1
\&       Return value: Nothing meaningful.
.Ve
.IP "array \fBsystem.listMethods\fR ()" 4
.IX Item "array system.listMethods ()"
.Vb 1
\&   Return an array of all available XML\-RPC methods on this server.
.Ve
.IP "string \fBsystem.methodHelp\fR (string)" 4
.IX Item "string system.methodHelp (string)"
.Vb 1
\&   Given the name of a method, return a help string.
.Ve
.IP "array \fBsystem.methodSignature\fR (string)" 4
.IX Item "array system.methodSignature (string)"
.Vb 3
\&   Given the name of a method, return an array of legal signatures. Each
\&           signature is an array of strings. The first item of each signature is
\&           the return type, and any others items are parameter types.
.Ve
.IP "array \fBsystem.multicall\fR (array)" 4
.IX Item "array system.multicall (array)"
.Vb 6
\&   Process an array of calls, and return an array of results. Calls
\&           should be structs of the form {'methodName': string, 'params': array}.
\&           Each result will either be a single\-item array containg the result
\&           value, or a struct of the form {'faultCode': int, 'faultString':
\&           string}. This is useful when you need to make lots of small calls
\&           without lots of round trips.
.Ve
.IP "boolean \fBtoggle_loop_mode\fR ()" 4
.IX Item "boolean toggle_loop_mode ()"
.Vb 1
\&   Turns loop mode on if it is off, and turns it off if it is on.
.Ve
.Sp
.Vb 3
\&       If loop mode is on, songs are returned to the end of the song queue after
\&       they finish playing.  If loop mode is off, songs that have finished playing
\&       are not returned to the queue.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBtoggle_pause\fR ()" 4
.IX Item "boolean toggle_pause ()"
.Vb 1
\&   Pauses the current song if it is playing, and unpauses if it is paused.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "boolean \fBunpause\fR ()" 4
.IX Item "boolean unpause ()"
.Vb 1
\&   Unpauses the current song.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: Nothing meaningful.
.Ve
.IP "string \fBversion\fR ()" 4
.IX Item "string version ()"
.Vb 1
\&   Returns the Moosic server's version string.
.Ve
.Sp
.Vb 2
\&       Arguments: None.
\&       Return value: The version string for the Moosic server.
.Ve
.SH "Section 4: Writing a Moosic Client in Python"
.IX Header "Section 4: Writing a Moosic Client in Python"
As demonstrated in section 0, communicating with a Moosic server is very easy to
do with Python.  In this section, I'll merely elaborate on the details that were
omitted from section 0 for the sake of brevity.
.PP
First of all, you should know that \fILocalMoosicProxy()\fR can be called with a
filename argument to specify the location of the Moosic server's socket file.
This is useful if moosicd was started with the \*(L"\-c\*(R" option.  Refer to the
moosic_factory.py module's documentation (moosic_factory.html).
.PP
Next, note that many of the Moosic server's methods accept or return special
types of objects from the xmlrpclib module, namely Boolean and Binary.  These
object types serve the purpose of bridging the small mismatch between the
data-types supported by XML-RPC and Python's intrinsic data\-types.  Boolean
objects present no unusual problem, since they evaluate to a correct truth value
without any extra effort.  However, you must take care when using the Moosic
methods that accept or return Binary objects.  Read the documentation for the
xmlrpclib module for details on how to work with these objects.  The basic
technique boils down to wrapping up a string inside a Binary object before
sending it to the server, and using the \*(L"data\*(R" attribute to access the string
data within the Binary objects returned by the server.  Regular strings can't be
used because \s-1XML\-RPC\s0's normal string data-type can't handle multiple 8\-bit
strings within a single request if the strings use different encodings.
.SH "Section 5: Writing a Moosic Client in Another Language"
.IX Header "Section 5: Writing a Moosic Client in Another Language"
If you are not using Python to write your Moosic client, the first issue to deal
with is deciding upon an XML-RPC implementation.  For most popular programming
languages, there are multiple XML-RPC implementations available.  Most of the
possibilities are listed at
<http://www.xmlrpc.com/directory/1568/implementations>.  Since XML-RPC is an
open specification, you can create your own implementation if you don't like any
of the ones that already exist.
.PP
Once you've got an XML-RPC library that you like, the big hurdle to overcome is
to make that library send its \s-1RPC\s0 calls over a Unix socket instead of an \s-1IP\s0
socket.  I was able to do this pretty easily with Python's xmlrpclib since it is
designed to allow pluggable transport methods:  all I had to do was subclass my
own Transport type and plug it back into the original library's classes.  (If
your language and/or library of choice makes this task difficult, then you may
begin to understand why some Python programmers are so smug.)
.PP
After you are capable of sending XML-RPC requests through a Unix socket, you can
go ahead and start sending requests to a Moosic server.  Refer to the end of
section 2 for information on how to address a Moosic server.  Refer to section 3
for a list of valid server requests.
.PP
If you can't be bothered to find or hack together an XML-RPC library that works
with Unix sockets, then you can still talk to a Moosic server that is listening
on an \s-1IP\s0 socket, but this is less than ideal since listening on an \s-1IP\s0 socket is
not default behavior for most Moosic servers.
.SH "Section 6: API Version History (ChangeLog)"
.IX Header "Section 6: API Version History (ChangeLog)"
.IP "* 1.8" 4
.IX Item "1.8"
First implemented in moosicd 1.5.1. The following methods were added:
.Sp
.Vb 1
\&    swap
.Ve
.IP "* 1.7" 4
.IX Item "1.7"
First implemented by moosicd 1.5.0. The following methods were added:
.Sp
.Vb 1
\&    skip, current_time
.Ve
.Sp
The following methods had their behavior significantly changed:
.Sp
.Vb 1
\&    previous, next
.Ve
.Sp
Specifically, the \fIprevious()\fR method no longer activates queue advancement if it
had been disabled before.  This means that calling \fIprevious()\fR no longer
necessarily causes a song to start playing.  The \fInext()\fR method was changed to
more closely parallel the behavior of \fIprevious()\fR: it takes a single optional
integer argument to allow immediate advancement by more than one song at a time,
and it has an effect even when no song is currently playing.  The new \fIskip()\fR
method implements the exact same behavior that was previously exhibited by
\&\fInext()\fR.
.Sp
Last, and most importantly, the name of the default socket file for
communicating with the server via unix sockets was changed from
\&\f(CW$CONFIG_DIR\fR/socket\-$HOSTNAME to \f(CW$CONFIG_DIR\fR/socket.  If you are a Python
programmer and you use the updated moosic_factory.py file from Moosic version
1.5.0, then you don't have to make any changes.  Otherwise, you must change your
client's code to connect to the file named \*(L"socket\*(R" instead of the file named
\&\*(L"socket\-something.example.com\*(R".  If your client only talks to the Moosic server
through \s-1TCP/IP\s0, then you don't have to make any changes, of course.
.IP "* 1.6" 4
.IX Item "1.6"
First implemented by moosicd 1.4.10. The following methods were added:
.Sp
.Vb 1
\&    getconfig
.Ve
.IP "* 1.5" 4
.IX Item "1.5"
First implemented by moosicd 1.4.6. The following methods were added:
.Sp
.Vb 1
\&    sub, sub_all, stop
.Ve
.IP "* 1.4" 4
.IX Item "1.4"
First implemented by moosicd 1.4.5. The following methods were added:
.Sp
.Vb 1
\&    previous
.Ve
.IP "* 1.3" 4
.IX Item "1.3"
First implemented by moosicd 1.4.4. The following methods were added:
.Sp
.Vb 1
\&    replace, replace_range, last_queue_update
.Ve
.IP "* 1.2" 4
.IX Item "1.2"
First implemented by moosicd 1.4.2. The following methods were added:
.Sp
.Vb 1
\&    cut_list, crop_list
.Ve
.IP "* 1.1" 4
.IX Item "1.1"
First implemented by moosicd 1.4.1. The following methods were added:
.Sp
.Vb 1
\&    is_looping, set_loop_mode, toggle_loop_mode
.Ve
.IP "* 1.0" 4
.IX Item "1.0"
First implemented by moosicd 1.4.0. The following methods were included:
.Sp
.Vb 7
\&    api_version, append, clear, crop, current, cut, die, filter,
\&    get_history_limit, halt_queue, haltqueue, history, indexed_list, insert,
\&    is_paused, is_queue_running, length, list, move, move_list, next, no_op,
\&    pause, prepend, putback, queue_length, reconfigure, remove, reverse,
\&    run_queue, runqueue, set_history_limit, showconfig, shuffle, sort,
\&    system.listMethods, system.methodHelp, system.methodSignature,
\&    system.multicall, toggle_pause, unpause, version
.Ve
